name: test-parser

on:
  workflow_dispatch:
    inputs:
      parser_kind:
        description: "Parser to use"
        type: choice
        required: true
        default: modern_tribe
        options: [modern_tribe, ai1ec, growthzone, ics]
      snapshot_pattern:
        description: "Glob for snapshots to list/test"
        type: string
        required: true
        default: "state/snapshots/*.html"
      max_files:
        description: "Max files to list/test (string; will be cast to int)"
        type: string
        required: true
        default: "15"
      run_mode:
        description: "What to do after listing"
        type: choice
        required: true
        default: list
        options: [list, single, matrix]
      index:
        description: "1-based index to parse when run_mode=single (string)"
        type: string
        required: true
        default: "1"

jobs:
  prep:
    name: Gather snapshot files
    runs-on: ubuntu-latest
    outputs:
      files_json: ${{ steps.setlist.outputs.files_json }}
      count: ${{ steps.setlist.outputs.count }}
      chosen_path: ${{ steps.pick.outputs.chosen_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show repo root and snapshots dir
        shell: bash
        run: |
          echo "Repo root: $(pwd)"
          echo
          echo "Top-level:"
          ls -la
          echo
          if [ -d state/snapshots ]; then
            echo "Snapshots dir (first 200 entries):"
            ls -la state/snapshots | sed -n '1,200p'
          else
            echo "Directory state/snapshots does not exist."
          fi

      - name: Collect matching files
        id: setlist
        shell: bash
        env:
          PATTERN: ${{ inputs.snapshot_pattern }}
          LIMIT: ${{ inputs.max_files }}
        run: |
          set -euo pipefail
          python - <<'PY'
import glob, json, os
pattern = os.environ.get("PATTERN","state/snapshots/*.html")
try:
    limit = int(os.environ.get("LIMIT","15"))
except Exception:
    limit = 15
matches = sorted([p for p in glob.glob(pattern) if os.path.isfile(p)])[:limit]
print("=== Matched files (limited to %d) ===" % limit)
if matches:
    for i, p in enumerate(matches, 1):
        print("%3d. %s" % (i, p))
else:
    print("(no matches)")
out = os.environ["GITHUB_OUTPUT"]
with open(out, "a") as fh:
    fh.write("files_json=" + json.dumps(matches) + "\n")
    fh.write("count=%d\n" % len(matches))
PY

      - name: Pretty list (always)
        shell: bash
        env:
          FILES_JSON: ${{ steps.setlist.outputs.files_json }}
        run: |
          set -euo pipefail
          python - <<'PY'
import json, os
files = []
try:
    files = json.loads(os.environ.get("FILES_JSON","[]"))
except Exception as e:
    print("Could not parse files_json:", e)
print("\nPretty list:")
if not files:
    print("  (no files)")
else:
    for i, p in enumerate(files, 1):
        print("  %2d) %s" % (i, p))
print()
PY

      - name: Pick single file (only if run_mode=single)
        id: pick
        if: ${{ inputs.run_mode == 'single' }}
        shell: bash
        env:
          FILES_JSON: ${{ steps.setlist.outputs.files_json }}
          INDEX: ${{ inputs.index }}
        run: |
          set -euo pipefail
          python - <<'PY'
import json, os, sys
try:
    files = json.loads(os.environ.get("FILES_JSON","[]"))
except Exception:
    files = []
try:
    idx = int(os.environ.get("INDEX","1"))
except Exception:
    idx = 1
chosen = ""
if not files:
    print("No files to choose from.")
elif 1 <= idx <= len(files):
    chosen = files[idx-1]
    print("Chosen #%d: %s" % (idx, chosen))
else:
    print("Index %d out of range 1..%d" % (idx, len(files)))
out = os.environ["GITHUB_OUTPUT"]
with open(out, "a") as fh:
    fh.write("chosen_path=%s\n" % chosen)
if not chosen:
    sys.exit(1)
PY

      - name: Stop after listing (when run_mode=list)
        if: ${{ inputs.run_mode == 'list' }}
        run: |
          echo "Run mode is 'list' â€” not parsing anything."
          exit 0

  single:
    name: Parse one snapshot
    runs-on: ubuntu-latest
    needs: prep
    if: ${{ inputs.run_mode == 'single' && needs.prep.outputs.chosen_path != '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        shell: bash
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else:
            pip install requests beautifulsoup4 lxml ics python-dateutil pytz
          fi

      - name: Show chosen file
        shell: bash
        run: |
          echo "Parsing: ${{ needs.prep.outputs.chosen_path }} with parser ${{ inputs.parser_kind }}"

      - name: Run parser
        shell: bash
        run: |
          python src/test_parser.py "${{ needs.prep.outputs.chosen_path }}" "${{ inputs.parser_kind }}"

  matrix:
    name: Parse N snapshots (matrix)
    runs-on: ubuntu-latest
    needs: prep
    if: ${{ inputs.run_mode == 'matrix' && needs.prep.outputs.count != '0' }}
    strategy:
      fail-fast: false
      matrix:
        file: ${{ fromJSON(needs.prep.outputs.files_json) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        shell: bash
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else:
            pip install requests beautifulsoup4 lxml ics python-dateutil pytz
          fi

      - name: Show file
        shell: bash
        run: |
          echo "Parsing: ${{ matrix.file }} with parser ${{ inputs.parser_kind }}"

      - name: Run parser
        shell: bash
        run: |
          python src/test_parser.py "${{ matrix.file }}" "${{ inputs.parser_kind }}"
