name: test-parser

on:
  workflow_dispatch:
    inputs:
      parser_kind:
        description: "Parser to use"
        type: choice
        required: true
        default: modern_tribe
        options: [modern_tribe, ai1ec, growthzone, ics]
      snapshot_pattern:
        description: "Glob for snapshots to list/test"
        type: string
        required: true
        default: "state/snapshots/*.html"
      max_files:
        description: "Max files to list/test (string; will be cast to int)"
        type: string
        required: true
        default: "15"
      run_mode:
        description: "What to do after listing"
        type: choice
        required: true
        default: list
        options: [list, single, matrix]
      index:
        description: "1-based index to parse when run_mode=single (string)"
        type: string
        required: true
        default: "1"

jobs:
  prep:
    name: Gather snapshot files
    runs-on: ubuntu-latest
    outputs:
      files_json: ${{ steps.setlist.outputs.files_json }}
      count: ${{ steps.setlist.outputs.count }}
      chosen_path: ${{ steps.pick.outputs.chosen_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show repo root and snapshots dir
        shell: bash
        run: |
          echo "Repo root: $(pwd)"
          echo
          echo "Top-level:"
          ls -la
          echo
          if [ -d state/snapshots ]; then
            echo "Snapshots dir (first 200 entries):"
            ls -la state/snapshots | sed -n '1,200p'
          else
            echo "Directory state/snapshots does not exist."
          fi

      - name: Collect matching files (bash + jq)
        id: setlist
        shell: bash
        env:
          PATTERN: ${{ inputs.snapshot_pattern }}
          LIMIT: ${{ inputs.max_files }}
        run: |
          set -euo pipefail
          echo "Pattern: ${PATTERN}"
          echo "Limit: ${LIMIT}"
          shopt -s nullglob
          # Expand glob safely, sort, then limit
          mapfile -t _matches < <(printf "%s\n" ${PATTERN} | xargs -I{} bash -lc 'printf "%s\n" {}' | xargs -I{} bash -lc 'printf "%s\n" {}' 2>/dev/null || true)
          # If the glob didn't expand literally (common), use compgen to expand
          if [ ${#_matches[@]} -eq 1 ] && [ "${_matches[0]}" = "${PATTERN}" ]; then
            mapfile -t _matches < <(compgen -G "${PATTERN}" || true)
          fi
          if [ ${#_matches[@]} -eq 0 ]; then
            echo "No matches found."
            FILES_JSON="[]"
          else
            # Sort and limit
            mapfile -t _sorted < <(printf "%s\n" "${_matches[@]}" | sort)
            # Limit
            _n="${LIMIT}"
            if ! [[ "$_n" =~ ^[0-9]+$ ]]; then _n=15; fi
            mapfile -t _limited < <(printf "%s\n" "${_sorted[@]}" | head -n "$_n")
            echo "=== Matched files (limited to ${_n}) ==="
            i=1
            for p in "${_limited[@]}"; do
              printf "%3d. %s\n" "$i" "$p"
              i=$((i+1))
            done
            # Build JSON array via jq
            FILES_JSON=$(printf "%s\n" "${_limited[@]}" | jq -R -s 'split("\n")|map(select(length>0))')
          fi
          echo "files_json=${FILES_JSON}" >> "$GITHUB_OUTPUT"
          echo "count=$(echo "${FILES_JSON}" | jq 'length')" >> "$GITHUB_OUTPUT"

      - name: Pretty list (always)
        shell: bash
        env:
          FILES_JSON: ${{ steps.setlist.outputs.files_json }}
        run: |
          set -euo pipefail
          echo
          echo "Pretty list:"
          echo "${FILES_JSON}" | jq -r 'to_entries[] | "  \(.key+1)) \(.value)"' || echo "  (no files)"
          echo

      - name: Pick single file (only if run_mode=single)
        id: pick
        if: ${{ inputs.run_mode == 'single' }}
        shell: bash
        env:
          FILES_JSON: ${{ steps.setlist.outputs.files_json }}
          INDEX: ${{ inputs.index }}
        run: |
          set -euo pipefail
          idx="${INDEX}"
          if ! [[ "$idx" =~ ^[0-9]+$ ]]; then idx=1; fi
          total=$(echo "${FILES_JSON}" | jq 'length')
          chosen=""
          if [ "${total}" -eq 0 ]; then
            echo "No files to choose from."
          else
            i=$((idx-1))
            if [ "$i" -ge 0 ] && [ "$i" -lt "${total}" ]; then
              chosen=$(echo "${FILES_JSON}" | jq -r ".[$i]")
              echo "Chosen #${idx}: ${chosen}"
            else
              echo "Index ${idx} out of range 1..${total}"
            fi
          fi
          echo "chosen_path=${chosen}" >> "$GITHUB_OUTPUT"
          if [ -z "${chosen}" ]; then
            exit 1
          fi

      - name: Stop after listing (when run_mode=list)
        if: ${{ inputs.run_mode == 'list' }}
        run: |
          echo "Run mode is 'list' â€” not parsing anything."
          exit 0

  single:
    name: Parse one snapshot
    runs-on: ubuntu-latest
    needs: prep
    if: ${{ inputs.run_mode == 'single' && needs.prep.outputs.chosen_path != '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        shell: bash
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else
            pip install requests beautifulsoup4 lxml ics python-dateutil pytz
          fi

      - name: Show chosen file
        shell: bash
        run: |
          echo "Parsing: ${{ needs.prep.outputs.chosen_path }} with parser ${{ inputs.parser_kind }}"

      - name: Run parser
        shell: bash
        run: |
          python src/test_parser.py "${{ needs.prep.outputs.chosen_path }}" "${{ inputs.parser_kind }}"

  matrix:
    name: Parse N snapshots (matrix)
    runs-on: ubuntu-latest
    needs: prep
    if: ${{ inputs.run_mode == 'matrix' && needs.prep.outputs.count != '0' }}
    strategy:
      fail-fast: false
      matrix:
        file: ${{ fromJSON(needs.prep.outputs.files_json) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        shell: bash
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else
            pip install requests beautifulsoup4 lxml ics python-dateutil pytz
          fi

      - name: Show file
        shell: bash
        run: |
          echo "Parsing: ${{ matrix.file }} with parser ${{ inputs.parser_kind }}"

      - name: Run parser
        shell: bash
        run: |
          python src/test_parser.py "${{ matrix.file }}" "${{ inputs.parser_kind }}"
